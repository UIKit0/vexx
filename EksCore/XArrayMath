#ifndef XARRAYMATH_H
#define XARRAYMATH_H

#include "XVector4D"
#include "XProperty"

class EKSCORE_EXPORT XMathsOperation
  {
public:
  enum OperationType
    {
    NoOp,
    Load,
    Add,
    AddConst,
    Multiply,
    MultiplyConst,
    Convolve,
    Shuffle,
    Splice
    };

XProperties:
  XROProperty(OperationType, operation);
  XROProperty(const XMathsOperation *, inputA);
  XROProperty(const XMathsOperation *, inputB);
  XROProperty(XVector4D, vectorData);
  XROProperty(xuint32, integerData);
  XROProperty(void *, userData);

public:
  XMathsOperation();
  ~XMathsOperation();

  enum DataType
    {
    None,
    Byte,
    HalfFloat,
    Float
    };

  void load(DataType, void* data, xsize dataWidth, xsize dataHeight, xsize dataChannels);

  void add(const XMathsOperation &, const XMathsOperation &);
  void add(const XMathsOperation &, const XVector4D &);

  void multiply(const XMathsOperation &, const XMathsOperation &);
  void multiply(const XMathsOperation &, const XVector4D &);

  void convolve(const XMathsOperation &, const XMathsOperation &);
  void shuffle(const XMathsOperation &, xuint32 mask);
  void splice(const XMathsOperation &, const XMathsOperation &, xuint32 mask);

private:
  XMathsOperation(const XMathsOperation &);
  XMathsOperation& operator=(const XMathsOperation &);

  void setInputDirty();
  void setOperationDirty();
  void setValueDirty();

  void setValue(const XVector4D &);
  void setValue(xuint32 );
  void setOperation(OperationType t);
  void setInput(const XMathsOperation **inp, const XMathsOperation *in);
  void addUser(XMathsOperation*) const;
  void removeUser(XMathsOperation*) const;

  mutable XMathsOperation *_user;
  mutable XMathsOperation *_nextUser;
  };

class EKSCORE_EXPORT XMathsEngine
  {
public:
  virtual void *loadData(XMathsOperation::DataType type, void* data, xsize width, xsize height, xuint8 channels) = 0;
  virtual void onOperationDirty(const XMathsOperation *, void **userData) = 0;
  virtual void onValueDirty(const XMathsOperation *, void **userData) = 0;
  virtual void onInputDirty(const XMathsOperation *, void **userData) = 0;
  virtual void onCleanUp(const XMathsOperation *, void **userData) = 0;

  static XMathsEngine *engine();
  static void setEngine(XMathsEngine *);
  };

class EKSCORE_EXPORT XReferenceMathsEngine : public XMathsEngine
  {
  virtual void *loadData(XMathsOperation::DataType type, void* data, xsize width, xsize height, xuint8 channels);
  virtual void onOperationDirty(const XMathsOperation *, void **userData);
  virtual void onValueDirty(const XMathsOperation *, void **userData);
  virtual void onInputDirty(const XMathsOperation *, void **userData);
  virtual void onCleanUp(const XMathsOperation *, void **userData);
  };

class EKSCORE_EXPORT XMathsResult
  {
public:
  XMathsResult(const XMathsOperation &);

  XMathsOperation::DataType dataType() const;
  xuint8 *data() const;
  xsize dataWidth() const;
  xsize dataHeight() const;

private:
  XMathsResult(const XMathsResult &);
  XMathsResult& operator=(const XMathsResult &);
  };

#endif // XARRAYMATH_H

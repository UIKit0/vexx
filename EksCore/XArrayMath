#ifndef XARRAYMATH_H
#define XARRAYMATH_H

#include "XMatrix3x3"
#include "XVector4D"
#include "QRectF"
#include "XProperty"
#include "XAssert"

class EKSCORE_EXPORT XMathsOperation
  {
public:
  enum OperationType
    {
    NoOp,
    Load,
    Add,
    AddConst,
    Multiply,
    MultiplyConst,
    Convolve,
    Shuffle,
    Splice
    };

XProperties:
  XROProperty(OperationType, operation);
  XROProperty(const XMathsOperation *, inputA);
  XROProperty(const XMathsOperation *, inputB);
  XROProperty(XVector4D, vectorData);
  XROProperty(xuint32, integerData);
  XROProperty(void *, userData);

public:
  XMathsOperation();
  ~XMathsOperation();

  bool operator!=(const XMathsOperation &op) const
    {
    return !(*this == op);
    }
  bool operator==(const XMathsOperation &op) const
    {
    return op.inputA() == inputA() &&
            op.inputB() == inputB() &&
            op.operation() == operation() &&
            op.vectorData() == vectorData() &&
            op.integerData() == integerData();
    }

  enum DataType
    {
    None,
    Byte,
    UnsignedInt,
    HalfFloat,
    Float
    };

  void copy(const XMathsOperation &op);
  void load(DataType, void* data, xsize stride, xsize dataWidth, xsize dataHeight, xsize dataChannels, const XMatrix3x3 &);

  void add(const XMathsOperation &, const XMathsOperation &);
  void add(const XMathsOperation &, const XVector4D &);

  void multiply(const XMathsOperation &, const XMathsOperation &);
  void multiply(const XMathsOperation &, const XVector4D &);

  enum ShuffleSpecialTypes
    {
    ShuffleOne = 255,
    ShuffleZero = 254,
    };

  void convolve(const XMathsOperation &, const XMathsOperation &);
  void shuffle(const XMathsOperation &, xuint32 mask);
  void splice(const XMathsOperation &, const XMathsOperation &, xuint32 mask);

  void transform(const XMathsOperation &, const XMatrix3x3 &);

  static inline xuint32 shuffleMask(xuint8 c0, xuint8 c1, xuint8 c2, xuint8 c3)
    {
    xAssert(c0 < 4);
    xAssert(c1 < 4);
    xAssert(c2 < 4);
    xAssert(c3 < 4);

    xuint32 mask = 0;
    mask |= c0;
    mask |= c1 << 8;
    mask |= c2 << 16;
    mask |= c3 << 24;
    return mask;
    }

    static void shuffleComponents(xuint32 comp, xuint8 out[4])
    {
    xuint32 *outInt = (xuint32*)out;
    *outInt = comp;
    }

private:
  XMathsOperation(const XMathsOperation &);
  XMathsOperation& operator=(const XMathsOperation &);

  void setInputDirty();
  void setOperationDirty();
  void setValueDirty();

  void setValue(const XVector4D &);
  void setValue(xuint32 );
  void setOperation(OperationType t);
  void setInput(const XMathsOperation **inp, const XMathsOperation *in);
  void addUser(XMathsOperation*) const;
  void removeUser(XMathsOperation*) const;

  mutable XMathsOperation *_user;
  mutable XMathsOperation *_nextUser;
  };

class EKSCORE_EXPORT XMathsEngine
  {
public:
  virtual void evaluateData(const XMathsOperation *, const void *userData, QRectF sampleRect, xuint32 invSampleDensity, XMathsOperation::DataType *type, const void **data, xsize *dataStride, xsize *dataWidth, xsize *dataHeight, xsize *dataChannels, XMatrix3x3 *m) = 0;
  virtual void *loadData(XMathsOperation::DataType type, void* data, xsize stride, xsize width, xsize height, xuint8 channels, const XMatrix3x3 &) = 0;
  virtual void onOperationDirty(const XMathsOperation *, void **userData) = 0;
  virtual void onValueDirty(const XMathsOperation *, void **userData) = 0;
  virtual void onInputDirty(const XMathsOperation *, void **userData) = 0;
  virtual void onCleanUp(const XMathsOperation *, void **userData) = 0;

  static XMathsEngine *engine();
  static void setEngine(XMathsEngine *);
  };

class EKSCORE_EXPORT XReferenceMathsEngine : public XMathsEngine
  {
  virtual void evaluateData(const XMathsOperation *, const void *userData, QRectF sampleRect, xuint32 invSampleDensity, XMathsOperation::DataType *type, const void **data, xsize *dataStride, xsize *dataWidth, xsize *dataHeight, xsize *dataChannels, XMatrix3x3 *m);
  virtual void *loadData(XMathsOperation::DataType type, void* data, xsize stride, xsize width, xsize height, xuint8 channels, const XMatrix3x3 &);
  virtual void onOperationDirty(const XMathsOperation *, void **userData);
  virtual void onValueDirty(const XMathsOperation *, void **userData);
  virtual void onInputDirty(const XMathsOperation *, void **userData);
  virtual void onCleanUp(const XMathsOperation *, void **userData);
  };

class EKSCORE_EXPORT XMathsResult
  {
XProperties:
  XROProperty(XMathsOperation::DataType, dataType);
  XROProperty(const void *, data);
  XROProperty(xsize, dataStride);
  XROProperty(xsize, dataWidth);
  XROProperty(xsize, dataHeight);
  XROProperty(xsize, dataChannels);
  XRORefProperty(XMatrix3x3, transform);

public:
  XMathsResult(const XMathsOperation &, QRectF sampleRect=QRectF(), xuint32 invSampleDensity=1);

private:
  XMathsResult(const XMathsResult &);
  XMathsResult& operator=(const XMathsResult &);
  };

#endif // XARRAYMATH_H
